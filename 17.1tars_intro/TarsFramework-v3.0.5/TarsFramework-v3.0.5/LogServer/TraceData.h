// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 3.0.0.
// **********************************************************************

#ifndef __TRACEDATA_H_
#define __TRACEDATA_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
#include "tup/TarsJson.h"
using namespace std;


namespace internal
{
    struct IRawLog : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "internal.IRawLog";
        }
        static string MD5()
        {
            return "b7e1cf7dcb25d5db80ae1e786d7676ed";
        }
        IRawLog()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            trace = "";
            span = "";
            parent = "";
            type = "";
            master = "";
            slave = "";
            function = "";
            time = 0;
            ret = "";
            data = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(trace, 0);
            _os.write(span, 1);
            _os.write(parent, 2);
            _os.write(type, 3);
            _os.write(master, 4);
            _os.write(slave, 5);
            _os.write(function, 6);
            _os.write(time, 7);
            _os.write(ret, 8);
            _os.write(data, 9);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(trace, 0, true);
            _is.read(span, 1, true);
            _is.read(parent, 2, true);
            _is.read(type, 3, true);
            _is.read(master, 4, true);
            _is.read(slave, 5, true);
            _is.read(function, 6, true);
            _is.read(time, 7, true);
            _is.read(ret, 8, true);
            _is.read(data, 9, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["trace"] = tars::JsonOutput::writeJson(trace);
            p->value["span"] = tars::JsonOutput::writeJson(span);
            p->value["parent"] = tars::JsonOutput::writeJson(parent);
            p->value["type"] = tars::JsonOutput::writeJson(type);
            p->value["master"] = tars::JsonOutput::writeJson(master);
            p->value["slave"] = tars::JsonOutput::writeJson(slave);
            p->value["function"] = tars::JsonOutput::writeJson(function);
            p->value["time"] = tars::JsonOutput::writeJson(time);
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["data"] = tars::JsonOutput::writeJson(data);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(trace,pObj->value["trace"], true);
            tars::JsonInput::readJson(span,pObj->value["span"], true);
            tars::JsonInput::readJson(parent,pObj->value["parent"], true);
            tars::JsonInput::readJson(type,pObj->value["type"], true);
            tars::JsonInput::readJson(master,pObj->value["master"], true);
            tars::JsonInput::readJson(slave,pObj->value["slave"], true);
            tars::JsonInput::readJson(function,pObj->value["function"], true);
            tars::JsonInput::readJson(time,pObj->value["time"], true);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(data,pObj->value["data"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(trace,"trace");
            _ds.display(span,"span");
            _ds.display(parent,"parent");
            _ds.display(type,"type");
            _ds.display(master,"master");
            _ds.display(slave,"slave");
            _ds.display(function,"function");
            _ds.display(time,"time");
            _ds.display(ret,"ret");
            _ds.display(data,"data");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(trace, true);
            _ds.displaySimple(span, true);
            _ds.displaySimple(parent, true);
            _ds.displaySimple(type, true);
            _ds.displaySimple(master, true);
            _ds.displaySimple(slave, true);
            _ds.displaySimple(function, true);
            _ds.displaySimple(time, true);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(data, false);
            return _os;
        }
    public:
        std::string trace;
        std::string span;
        std::string parent;
        std::string type;
        std::string master;
        std::string slave;
        std::string function;
        tars::Int64 time;
        std::string ret;
        std::string data;
    };
    inline bool operator==(const IRawLog&l, const IRawLog&r)
    {
        return l.trace == r.trace && l.span == r.span && l.parent == r.parent && l.type == r.type && l.master == r.master && l.slave == r.slave && l.function == r.function && l.time == r.time && l.ret == r.ret && l.data == r.data;
    }
    inline bool operator!=(const IRawLog&l, const IRawLog&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const IRawLog&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,IRawLog&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ISpan : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "internal.ISpan";
        }
        static string MD5()
        {
            return "e346fdd88f833720a1fbceb248ea4b9b";
        }
        ISpan()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            span = "";
            parent = "";
            master = "";
            slave = "";
            function = "";
            csTime = 0;
            crTime = 0;
            ssTime = 0;
            srTime = 0;
            csData = "";
            srData = "";
            ssData = "";
            crData = "";
            ret = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(span, 0);
            _os.write(parent, 1);
            _os.write(master, 2);
            _os.write(slave, 3);
            _os.write(function, 4);
            _os.write(csTime, 5);
            _os.write(crTime, 6);
            _os.write(ssTime, 7);
            _os.write(srTime, 8);
            _os.write(csData, 9);
            _os.write(srData, 10);
            _os.write(ssData, 11);
            _os.write(crData, 12);
            _os.write(ret, 13);
            _os.write(children, 14);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(span, 0, true);
            _is.read(parent, 1, true);
            _is.read(master, 2, true);
            _is.read(slave, 3, true);
            _is.read(function, 4, true);
            _is.read(csTime, 5, true);
            _is.read(crTime, 6, true);
            _is.read(ssTime, 7, true);
            _is.read(srTime, 8, true);
            _is.read(csData, 9, true);
            _is.read(srData, 10, true);
            _is.read(ssData, 11, true);
            _is.read(crData, 12, true);
            _is.read(ret, 13, true);
            _is.read(children, 14, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["span"] = tars::JsonOutput::writeJson(span);
            p->value["parent"] = tars::JsonOutput::writeJson(parent);
            p->value["master"] = tars::JsonOutput::writeJson(master);
            p->value["slave"] = tars::JsonOutput::writeJson(slave);
            p->value["function"] = tars::JsonOutput::writeJson(function);
            p->value["csTime"] = tars::JsonOutput::writeJson(csTime);
            p->value["crTime"] = tars::JsonOutput::writeJson(crTime);
            p->value["ssTime"] = tars::JsonOutput::writeJson(ssTime);
            p->value["srTime"] = tars::JsonOutput::writeJson(srTime);
            p->value["csData"] = tars::JsonOutput::writeJson(csData);
            p->value["srData"] = tars::JsonOutput::writeJson(srData);
            p->value["ssData"] = tars::JsonOutput::writeJson(ssData);
            p->value["crData"] = tars::JsonOutput::writeJson(crData);
            p->value["ret"] = tars::JsonOutput::writeJson(ret);
            p->value["children"] = tars::JsonOutput::writeJson(children);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(span,pObj->value["span"], true);
            tars::JsonInput::readJson(parent,pObj->value["parent"], true);
            tars::JsonInput::readJson(master,pObj->value["master"], true);
            tars::JsonInput::readJson(slave,pObj->value["slave"], true);
            tars::JsonInput::readJson(function,pObj->value["function"], true);
            tars::JsonInput::readJson(csTime,pObj->value["csTime"], true);
            tars::JsonInput::readJson(crTime,pObj->value["crTime"], true);
            tars::JsonInput::readJson(ssTime,pObj->value["ssTime"], true);
            tars::JsonInput::readJson(srTime,pObj->value["srTime"], true);
            tars::JsonInput::readJson(csData,pObj->value["csData"], true);
            tars::JsonInput::readJson(srData,pObj->value["srData"], true);
            tars::JsonInput::readJson(ssData,pObj->value["ssData"], true);
            tars::JsonInput::readJson(crData,pObj->value["crData"], true);
            tars::JsonInput::readJson(ret,pObj->value["ret"], true);
            tars::JsonInput::readJson(children,pObj->value["children"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(span,"span");
            _ds.display(parent,"parent");
            _ds.display(master,"master");
            _ds.display(slave,"slave");
            _ds.display(function,"function");
            _ds.display(csTime,"csTime");
            _ds.display(crTime,"crTime");
            _ds.display(ssTime,"ssTime");
            _ds.display(srTime,"srTime");
            _ds.display(csData,"csData");
            _ds.display(srData,"srData");
            _ds.display(ssData,"ssData");
            _ds.display(crData,"crData");
            _ds.display(ret,"ret");
            _ds.display(children,"children");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(span, true);
            _ds.displaySimple(parent, true);
            _ds.displaySimple(master, true);
            _ds.displaySimple(slave, true);
            _ds.displaySimple(function, true);
            _ds.displaySimple(csTime, true);
            _ds.displaySimple(crTime, true);
            _ds.displaySimple(ssTime, true);
            _ds.displaySimple(srTime, true);
            _ds.displaySimple(csData, true);
            _ds.displaySimple(srData, true);
            _ds.displaySimple(ssData, true);
            _ds.displaySimple(crData, true);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(children, false);
            return _os;
        }
    public:
        std::string span;
        std::string parent;
        std::string master;
        std::string slave;
        std::string function;
        tars::Int64 csTime;
        tars::Int64 crTime;
        tars::Int64 ssTime;
        tars::Int64 srTime;
        std::string csData;
        std::string srData;
        std::string ssData;
        std::string crData;
        std::string ret;
        vector<std::string> children;
    };
    inline bool operator==(const ISpan&l, const ISpan&r)
    {
        return l.span == r.span && l.parent == r.parent && l.master == r.master && l.slave == r.slave && l.function == r.function && l.csTime == r.csTime && l.crTime == r.crTime && l.ssTime == r.ssTime && l.srTime == r.srTime && l.csData == r.csData && l.srData == r.srData && l.ssData == r.ssData && l.crData == r.crData && l.ret == r.ret && l.children == r.children;
    }
    inline bool operator!=(const ISpan&l, const ISpan&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ISpan&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ISpan&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ITrace : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "internal.ITrace";
        }
        static string MD5()
        {
            return "db057550f3f804530e87e7fd9d803bb1";
        }
        ITrace()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            trace = "";
            tSpan = "";
            tMaster = "";
            tsTime = 0;
            teTime = 0;
            sHash = 0;
            fHash = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(trace, 0);
            _os.write(tSpan, 1);
            _os.write(tMaster, 2);
            _os.write(tsTime, 3);
            _os.write(teTime, 4);
            _os.write(spans, 5);
            _os.write(sHash, 6);
            _os.write(fHash, 7);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(trace, 0, true);
            _is.read(tSpan, 1, true);
            _is.read(tMaster, 2, true);
            _is.read(tsTime, 3, true);
            _is.read(teTime, 4, true);
            _is.read(spans, 5, true);
            _is.read(sHash, 6, true);
            _is.read(fHash, 7, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["trace"] = tars::JsonOutput::writeJson(trace);
            p->value["tSpan"] = tars::JsonOutput::writeJson(tSpan);
            p->value["tMaster"] = tars::JsonOutput::writeJson(tMaster);
            p->value["tsTime"] = tars::JsonOutput::writeJson(tsTime);
            p->value["teTime"] = tars::JsonOutput::writeJson(teTime);
            p->value["spans"] = tars::JsonOutput::writeJson(spans);
            p->value["sHash"] = tars::JsonOutput::writeJson(sHash);
            p->value["fHash"] = tars::JsonOutput::writeJson(fHash);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(trace,pObj->value["trace"], true);
            tars::JsonInput::readJson(tSpan,pObj->value["tSpan"], true);
            tars::JsonInput::readJson(tMaster,pObj->value["tMaster"], true);
            tars::JsonInput::readJson(tsTime,pObj->value["tsTime"], true);
            tars::JsonInput::readJson(teTime,pObj->value["teTime"], true);
            tars::JsonInput::readJson(spans,pObj->value["spans"], true);
            tars::JsonInput::readJson(sHash,pObj->value["sHash"], true);
            tars::JsonInput::readJson(fHash,pObj->value["fHash"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(trace,"trace");
            _ds.display(tSpan,"tSpan");
            _ds.display(tMaster,"tMaster");
            _ds.display(tsTime,"tsTime");
            _ds.display(teTime,"teTime");
            _ds.display(spans,"spans");
            _ds.display(sHash,"sHash");
            _ds.display(fHash,"fHash");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(trace, true);
            _ds.displaySimple(tSpan, true);
            _ds.displaySimple(tMaster, true);
            _ds.displaySimple(tsTime, true);
            _ds.displaySimple(teTime, true);
            _ds.displaySimple(spans, true);
            _ds.displaySimple(sHash, true);
            _ds.displaySimple(fHash, false);
            return _os;
        }
    public:
        std::string trace;
        std::string tSpan;
        std::string tMaster;
        tars::Int64 tsTime;
        tars::Int64 teTime;
        vector<internal::ISpan> spans;
        tars::Int64 sHash;
        tars::Int64 fHash;
    };
    inline bool operator==(const ITrace&l, const ITrace&r)
    {
        return l.trace == r.trace && l.tSpan == r.tSpan && l.tMaster == r.tMaster && l.tsTime == r.tsTime && l.teTime == r.teTime && l.spans == r.spans && l.sHash == r.sHash && l.fHash == r.fHash;
    }
    inline bool operator!=(const ITrace&l, const ITrace&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ITrace&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ITrace&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct IVertex : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "internal.IVertex";
        }
        static string MD5()
        {
            return "cc5e0e2b7b5ef9452273b36ff9f9df39";
        }
        IVertex()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            vertex = "";
            callCount = 0;
            callTime = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(vertex, 0);
            _os.write(callCount, 1);
            _os.write(callTime, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(vertex, 0, true);
            _is.read(callCount, 1, true);
            _is.read(callTime, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["vertex"] = tars::JsonOutput::writeJson(vertex);
            p->value["callCount"] = tars::JsonOutput::writeJson(callCount);
            p->value["callTime"] = tars::JsonOutput::writeJson(callTime);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(vertex,pObj->value["vertex"], true);
            tars::JsonInput::readJson(callCount,pObj->value["callCount"], true);
            tars::JsonInput::readJson(callTime,pObj->value["callTime"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(vertex,"vertex");
            _ds.display(callCount,"callCount");
            _ds.display(callTime,"callTime");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(vertex, true);
            _ds.displaySimple(callCount, true);
            _ds.displaySimple(callTime, false);
            return _os;
        }
    public:
        std::string vertex;
        tars::Int64 callCount;
        tars::Int64 callTime;
    };
    inline bool operator==(const IVertex&l, const IVertex&r)
    {
        return l.vertex == r.vertex && l.callCount == r.callCount && l.callTime == r.callTime;
    }
    inline bool operator!=(const IVertex&l, const IVertex&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const IVertex&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,IVertex&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }
    inline bool operator<(const IVertex&l, const IVertex&r)
    {
        if(l.vertex != r.vertex)  return (l.vertex < r.vertex);
        return false;
    }
    inline bool operator<=(const IVertex&l, const IVertex&r)
    {
        return !(r < l);
    }
    inline bool operator>(const IVertex&l, const IVertex&r)
    {
        return r < l;
    }
    inline bool operator>=(const IVertex&l, const IVertex&r)
    {
        return !(l < r);
    }

    struct IEdge : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "internal.IEdge";
        }
        static string MD5()
        {
            return "8fe7097604fa54184f8872515c8878a7";
        }
        IEdge()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            fromVertex = "";
            toVertex = "";
            callCount = 0;
            callTime = 0;
            order = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(fromVertex, 0);
            _os.write(toVertex, 1);
            _os.write(callCount, 2);
            _os.write(callTime, 3);
            _os.write(order, 4);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(fromVertex, 0, true);
            _is.read(toVertex, 1, true);
            _is.read(callCount, 2, true);
            _is.read(callTime, 3, true);
            _is.read(order, 4, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["fromVertex"] = tars::JsonOutput::writeJson(fromVertex);
            p->value["toVertex"] = tars::JsonOutput::writeJson(toVertex);
            p->value["callCount"] = tars::JsonOutput::writeJson(callCount);
            p->value["callTime"] = tars::JsonOutput::writeJson(callTime);
            p->value["order"] = tars::JsonOutput::writeJson(order);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(fromVertex,pObj->value["fromVertex"], true);
            tars::JsonInput::readJson(toVertex,pObj->value["toVertex"], true);
            tars::JsonInput::readJson(callCount,pObj->value["callCount"], true);
            tars::JsonInput::readJson(callTime,pObj->value["callTime"], true);
            tars::JsonInput::readJson(order,pObj->value["order"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(fromVertex,"fromVertex");
            _ds.display(toVertex,"toVertex");
            _ds.display(callCount,"callCount");
            _ds.display(callTime,"callTime");
            _ds.display(order,"order");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(fromVertex, true);
            _ds.displaySimple(toVertex, true);
            _ds.displaySimple(callCount, true);
            _ds.displaySimple(callTime, true);
            _ds.displaySimple(order, false);
            return _os;
        }
    public:
        std::string fromVertex;
        std::string toVertex;
        tars::Int64 callCount;
        tars::Int64 callTime;
        tars::Int32 order;
    };
    inline bool operator==(const IEdge&l, const IEdge&r)
    {
        return l.fromVertex == r.fromVertex && l.toVertex == r.toVertex && l.callCount == r.callCount && l.callTime == r.callTime && l.order == r.order;
    }
    inline bool operator!=(const IEdge&l, const IEdge&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const IEdge&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,IEdge&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }
    inline bool operator<(const IEdge&l, const IEdge&r)
    {
        if(l.order != r.order)  return (l.order < r.order);
        if(l.fromVertex != r.fromVertex)  return (l.fromVertex < r.fromVertex);
        if(l.toVertex != r.toVertex)  return (l.toVertex < r.toVertex);
        return false;
    }
    inline bool operator<=(const IEdge&l, const IEdge&r)
    {
        return !(r < l);
    }
    inline bool operator>(const IEdge&l, const IEdge&r)
    {
        return r < l;
    }
    inline bool operator>=(const IEdge&l, const IEdge&r)
    {
        return !(l < r);
    }

    struct IGraph : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "internal.IGraph";
        }
        static string MD5()
        {
            return "a3dd96aecfc435969d9693af09ef53c4";
        }
        IGraph()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            type = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(type, 0);
            _os.write(vertexes, 1);
            _os.write(edges, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(type, 0, true);
            _is.read(vertexes, 1, true);
            _is.read(edges, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["type"] = tars::JsonOutput::writeJson(type);
            p->value["vertexes"] = tars::JsonOutput::writeJson(vertexes);
            p->value["edges"] = tars::JsonOutput::writeJson(edges);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(type,pObj->value["type"], true);
            tars::JsonInput::readJson(vertexes,pObj->value["vertexes"], true);
            tars::JsonInput::readJson(edges,pObj->value["edges"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(type,"type");
            _ds.display(vertexes,"vertexes");
            _ds.display(edges,"edges");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(type, true);
            _ds.displaySimple(vertexes, true);
            _ds.displaySimple(edges, false);
            return _os;
        }
    public:
        std::string type;
        vector<internal::IVertex> vertexes;
        vector<internal::IEdge> edges;
    };
    inline bool operator==(const IGraph&l, const IGraph&r)
    {
        return l.type == r.type && l.vertexes == r.vertexes && l.edges == r.edges;
    }
    inline bool operator!=(const IGraph&l, const IGraph&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const IGraph&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,IGraph&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct Snapshot : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "internal.Snapshot";
        }
        static string MD5()
        {
            return "3fd73cbd8ea22cc6e29f5159d4c8e7d8";
        }
        Snapshot()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            fileName = "";
            seek = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(fileName, 0);
            _os.write(seek, 1);
            _os.write(traces, 2);
            _os.write(graphs, 3);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(fileName, 0, true);
            _is.read(seek, 1, true);
            _is.read(traces, 2, true);
            _is.read(graphs, 3, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["fileName"] = tars::JsonOutput::writeJson(fileName);
            p->value["seek"] = tars::JsonOutput::writeJson(seek);
            p->value["traces"] = tars::JsonOutput::writeJson(traces);
            p->value["graphs"] = tars::JsonOutput::writeJson(graphs);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(fileName,pObj->value["fileName"], true);
            tars::JsonInput::readJson(seek,pObj->value["seek"], true);
            tars::JsonInput::readJson(traces,pObj->value["traces"], true);
            tars::JsonInput::readJson(graphs,pObj->value["graphs"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(fileName,"fileName");
            _ds.display(seek,"seek");
            _ds.display(traces,"traces");
            _ds.display(graphs,"graphs");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(fileName, true);
            _ds.displaySimple(seek, true);
            _ds.displaySimple(traces, true);
            _ds.displaySimple(graphs, false);
            return _os;
        }
    public:
        std::string fileName;
        tars::Int64 seek;
        map<std::string, internal::ITrace> traces;
        map<tars::Int64, internal::IGraph> graphs;
    };
    inline bool operator==(const Snapshot&l, const Snapshot&r)
    {
        return l.fileName == r.fileName && l.seek == r.seek && l.traces == r.traces && l.graphs == r.graphs;
    }
    inline bool operator!=(const Snapshot&l, const Snapshot&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const Snapshot&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,Snapshot&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }


}



#endif
