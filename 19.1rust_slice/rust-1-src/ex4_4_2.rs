//不正确
test1(){
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s;

    println!("{}, {}", r1, r2);

}

// 正确
 test2(){
    let  s = String::from("hello");

    let r1 = &s;
    let r2 = &s;

    println!("{}, {}", r1, r2);

}
/*
可以将可变引用看作是一把独占锁。在当前作用域内，从第一次使用可变引用开始创建这把独占锁，
之后无论使用原始变量(即所有权拥有者)、可变引用还是不可变引用都会抢占这把独占锁，以保证
只有一方可以访问数据，每次抢得独占锁后，都会将之前所有引用变量给锁住(原始变量依然可用)，
使它们变成不可用状态。当离开当前作用域时，当前作用域内的所有独占锁都被释放。
因此，可变引用是抢占且排他的，将其称为抢占式独占锁更为合适。
*/
fn test3(){
    let mut x = 33;
    let y = &mut x; // y获得独占锁
    x = *y + 1;     // 使用y获取数据后，x重新抢得独占锁
                    // 赋值之后，x有效，y将失效
    println!("{}", x);     // 正确
    // println!("{}", y);  // 错误
  }